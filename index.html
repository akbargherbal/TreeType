<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tree-Sitter Typing Game - Session 27 (Pause Feature)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Added for smooth scrolling on the root */
      html {
        scroll-behavior: smooth;
      }
      body {
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
      }

      .line {
        line-height: 1.6;
        padding: 2px 0;
        transition: background 0.2s;
      }

      /* Only show hover when test is NOT active */
      body:not(.test-active) .line:hover {
        background: #2a2a2a;
      }

      .line-number {
        user-select: none;
        color: #858585;
        text-align: right;
        padding-right: 16px;
        min-width: 40px;
      }

      /* Syntax highlighting colors (VS Code Dark+ theme) */
      .keyword {
        color: #569cd6;
      }
      .identifier {
        color: #9cdcfe;
      }
      .type_identifier {
        color: #4ec9b0;
      }
      .property_identifier {
        color: #9cdcfe;
      }
      .string_content {
        color: #ce9178;
      }
      .string_start,
      .string_end {
        color: #ce9178;
      }
      .number,
      .integer {
        color: #b5cea8;
      }
      .comment {
        color: #6a9955;
        font-style: italic;
      }
      .operator {
        color: #d4d4d4;
      }
      .punctuation {
        color: #d4d4d4;
      }
      .bracket {
        color: #ffd700;
      }

      .def,
      .function,
      .class,
      .return,
      .if,
      .elif,
      .else,
      .for,
      .while,
      .import,
      .from,
      .as,
      .const,
      .let,
      .var,
      .async,
      .await,
      .interface,
      .type,
      .export {
        color: #c586c0;
      }

      /* PHASE 3.5: Progressive reveal styles */
      .char-untyped {
        color: #858585 !important;
        opacity: 1;
      }

      .char-current {
        background: rgba(255, 255, 0, 0.3);
        border-bottom: 2px solid #fbbf24;
        animation: pulse 1s infinite;
      }

      .char-error {
        color: #ef4444 !important;
        background: rgba(239, 68, 68, 0.4);
        border: 2px solid #ef4444;
        border-radius: 2px;
      }

      @keyframes pulse {
        0%,
        100% {
          border-bottom-color: #fbbf24;
        }
        50% {
          border-bottom-color: #fcd34d;
        }
      }

      /* Active test indicator */
      .test-active-line {
        border-left: 4px solid #10b981;
      }

      /* Distraction-free mode: fade controls during active typing */
      .controls-area {
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      body.test-active .controls-area {
        opacity: 0.1;
      }

      body.test-active .controls-area:hover {
        opacity: 1;
      }

      /* Prevent instructions panel from triggering hover during auto-scroll */
      body.test-active .instructions-panel {
        pointer-events: none;
        opacity: 0.1;
      }
      /* Center the typing area for better ergonomics */
      #codeDisplay {
        outline: none;
        min-height: 60vh;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding-top: 2rem;
        padding-bottom: 2rem;
      }

      #codeDisplay.focused {
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      }

      /* Completion Modal */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        animation: fadeIn 0.3s;
      }

      .modal-content {
        background: #2a2a2a;
        border-radius: 12px;
        padding: 24px;
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: slideUp 0.3s;
        border: 2px solid #4ade80;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .modal-title {
        font-size: 2em;
        margin: 0;
      }

      .modal-subtitle {
        color: #9ca3af;
        margin: 0;
        font-size: 0.95em;
      }

      .modal-stats {
        background: #1e1e1e;
        border-radius: 8px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .modal-stat {
        margin: 0;
      }

      .modal-stat-label {
        color: #9ca3af;
        font-size: 0.9em;
      }

      .modal-stat-value {
        font-size: 1.8em;
        font-weight: bold;
        color: #4ade80;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin: 0;
        flex-wrap: wrap;
      }

      .modal-button {
        padding: 12px 24px;
        border-radius: 6px;
        border: none;
        font-size: 1em;
        cursor: pointer;
        transition: all 0.2s;
      }

      .modal-button-primary {
        background: #3b82f6;
        color: white;
      }

      .modal-button-primary:hover {
        background: #2563eb;
      }

      .modal-button-secondary {
        background: #374151;
        color: white;
      }

      .modal-button-secondary:hover {
        background: #4b5563;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* ===================================================================== */
      /* SESSION 27: PAUSE OVERLAY */
      /* ===================================================================== */

      .pause-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        animation: fadeIn 0.3s;
        backdrop-filter: blur(4px);
      }

      .pause-content {
        text-align: center;
        color: #d4d4d4;
        padding: 40px;
        background: #2a2a2a;
        border-radius: 12px;
        border: 2px solid #f59e0b;
        max-width: 450px;
      }

      .pause-icon {
        font-size: 4em;
        margin-bottom: 16px;
        animation: pausePulse 2s infinite;
      }

      @keyframes pausePulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.7;
          transform: scale(1.05);
        }
      }

      .pause-kbd {
        background: #374151;
        padding: 6px 12px;
        border-radius: 6px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 0.95em;
        border: 1px solid #4b5563;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        display: inline-block;
        margin: 0 4px;
      }

      /* Pause button active state */
      .paused-state {
        background: #10b981 !important;
      }

      .paused-state:hover {
        background: #059669 !important;
      }
    </style>
  </head>
  <body class="p-8">
    <div class="max-w-6xl mx-auto">
      <!-- Header & Controls: Wrapped for fade effect -->
      <div class="controls-area">
        <!-- Header -->
        <div class="mb-8">
          <h1 class="text-3xl font-bold mb-2">Tree-Sitter Typing Game</h1>
          <p class="text-gray-400">
            Build muscle memory for programming constructs
          </p>
        </div>

        <!-- Controls -->
        <div class="mb-6 flex gap-4 items-center flex-wrap">
          <label class="text-gray-300">Language:</label>
          <select
            id="languageSelect"
            class="bg-gray-800 text-white px-4 py-2 rounded border border-gray-600"
          >
            <option value="python">Python</option>
            <option value="javascript">JavaScript</option>
            <option value="typescript">TypeScript</option>
            <option value="tsx">TSX/React</option>
          </select>

          <!-- Typing Mode Selector -->
          <label class="text-gray-300 ml-6">Typing Mode:</label>
          <div class="flex gap-2">
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="minimal"
                class="cursor-pointer"
              />
              <span class="text-sm">Minimal</span>
            </label>
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="standard"
                checked
                class="cursor-pointer"
              />
              <span class="text-sm">Standard</span>
            </label>
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="full"
                class="cursor-pointer"
              />
              <span class="text-sm">Full</span>
            </label>
          </div>

          <!-- SESSION 27: Grouped action buttons -->
          <div class="flex gap-2 ml-auto">
            <button
              id="pauseBtn"
              class="bg-yellow-600 hover:bg-yellow-700 px-3 py-2 rounded text-sm font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed"
              onclick="togglePause()"
              disabled
            >
              ‚è∏Ô∏è Pause
            </button>

            <button
              id="resetBtn"
              class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm font-semibold transition"
            >
              üîÑ Reset
            </button>
          </div>

          <a
            href="library.html"
            class="bg-gray-700 hover:bg-gray-600 px-3 py-2 rounded text-sm font-semibold"
          >
            üìö Browse Library
          </a>

          <div id="testStatus" class="text-sm">
            <span class="text-gray-400">Press any key to start...</span>
          </div>
        </div>

        <!-- Stats Display -->
        <div id="stats" class="mb-6 p-4 bg-gray-800 rounded"></div>
      </div>

      <!-- Code Display -->
      <div
        id="codeDisplay"
        class="bg-gray-900 rounded-lg p-6 overflow-x-auto cursor-text"
        tabindex="0"
      >
        <div id="codeLines"></div>
      </div>

      <!-- Instructions: Also fade during typing -->
      <div
        class="mt-6 p-4 bg-gray-800 rounded controls-area instructions-panel"
      >
        <h3 class="font-bold mb-2">Instructions:</h3>
        <ul class="text-sm space-y-1 mb-4">
          <li>
            ‚Ä¢ <span class="text-gray-400">Gray text</span> = Not yet typed
          </li>
          <li>
            ‚Ä¢
            <span class="bg-yellow-500 bg-opacity-30 px-1"
              >Yellow highlight</span
            >
            = Current character to type
          </li>
          <li>
            ‚Ä¢ <span style="color: #569cd6">Colored text</span> = Already typed
            (syntax revealed)
          </li>
          <li>
            ‚Ä¢
            <span class="text-red-400 bg-red-900 bg-opacity-20 px-1"
              >Red highlight</span
            >
            = Wrong key (stays until corrected)
          </li>
          <li>
            ‚Ä¢ Press <kbd class="px-2 py-1 bg-gray-700 rounded">Tab</kbd> to
            pause/resume
          </li>
          <li>
            ‚Ä¢ Press <kbd class="px-2 py-1 bg-gray-700 rounded">Esc</kbd> to
            reset
          </li>
        </ul>

        <h3 class="font-bold mb-2 mt-4">Typing Modes:</h3>
        <ul class="text-sm space-y-1">
          <li>
            ‚Ä¢ <strong>Minimal</strong>: Type only keywords and identifiers
            (fastest)
          </li>
          <li>
            ‚Ä¢ <strong>Standard</strong> ‚≠ê: Type keywords, identifiers,
            operators, and <code>:</code> <code>;</code> (recommended)
          </li>
          <li>
            ‚Ä¢ <strong>Full</strong>: Type everything except whitespace and
            comments (maximum practice)
          </li>
        </ul>
      </div>
    </div>

    <script type="module">
      // =====================================================================
      // IMPORTS FROM TYPESCRIPT MODULES
      // =====================================================================

      import {
        getElapsedTime,
        calculateWPM,
        calculateAccuracy,
        formatTime,
      } from "./src/core/timer.js";

      import {
        PRESETS,
        DEFAULT_CONFIG,
        applyExclusionConfig,
        loadConfig,
        saveConfig,
      } from "./src/core/config.js";

      import {
        loadSnippetStats,
        saveSnippetStats,
      } from "./src/core/storage.js";

      // =====================================================================
      // STATE MANAGEMENT (SESSION 27: Added pause state)
      // =====================================================================

      let currentData = null;
      let rawData = null;
      let currentSnippetInfo = {
        path: null,
        id: null,
        language: null,
      };

      let testState = {
        active: false,
        paused: false, // SESSION 27: Pause state
        startTime: null,
        endTime: null,
        pauseStartTime: null, // SESSION 27: When current pause began
        totalPausedTime: 0, // SESSION 27: Cumulative pause duration (ms)
        currentLineIndex: 0,
        currentCharIndex: 0,
        totalCharsTyped: 0,
        totalErrors: 0,
        completedLines: new Set(),
        errorOnCurrentChar: false,
      };

      // =====================================================================
      // SESSION 26: RANDOM SNIPPET SELECTOR
      // =====================================================================

      async function loadRandomSnippet() {
        try {
          const response = await fetch("snippets/metadata.json");
          if (!response.ok) throw new Error("Cannot fetch metadata");

          const metadata = await response.json();
          const snippets = metadata.snippets;

          const randomSnippet =
            snippets[Math.floor(Math.random() * snippets.length)];

          window.location.href = `index.html?snippet=${encodeURIComponent(
            randomSnippet.path
          )}`;
        } catch (error) {
          console.error("Error loading random snippet:", error);
          alert("Could not load random snippet. Please try again.");
        }
      }

      // =====================================================================
      // LOAD LANGUAGE DATA (SESSION 26: Track snippet info)
      // =====================================================================

      async function loadLanguage(language) {
        const urlParams = new URLSearchParams(window.location.search);
        const snippetPath = urlParams.get("snippet");

        let fetchPath;
        if (snippetPath) {
          fetchPath = snippetPath;
        } else {
          const defaultSnippets = {
            python:
              "snippets/python/gm_01_001_02_03_core-python-patterns-quick-refresh.json",
            javascript: "snippets/javascript/gm_01_001_01_array-methods.json",
            typescript:
              "snippets/typescript/gm_01_026_01_apidata-patterns.json",
            tsx: "snippets/tsx/gm_01_014_01_async-patterns.json",
          };
          fetchPath = defaultSnippets[language];
        }

        try {
          const response = await fetch(fetchPath);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          rawData = await response.json();

          currentSnippetInfo.path = fetchPath;
          currentSnippetInfo.language = rawData.language;

          const pathParts = fetchPath.split("/");
          const filename = pathParts[pathParts.length - 1].replace(".json", "");
          const lang = pathParts[pathParts.length - 2];
          currentSnippetInfo.id = `${lang}-${filename}`;

          console.log("Loaded snippet:", currentSnippetInfo);

          const preset = document.querySelector(
            'input[name="typingMode"]:checked'
          ).value;

          currentData = {
            ...rawData,
            lines: rawData.lines.map((line) =>
              applyExclusionConfig(line, preset)
            ),
          };

          resetTest();

          setTimeout(() => {
            document.getElementById("codeDisplay").focus();
          }, 100);
        } catch (error) {
          console.error("Error loading file:", error);
          document.getElementById("codeLines").innerHTML = `
    <div class="text-red-400">
      Error loading snippet<br>
      Make sure you're running this from the project root directory.<br>
      Error: ${error.message}<br><br>
      <a href="library.html" class="text-blue-400 underline">Go to Library to select a snippet</a>
    </div>
  `;
        }
      }

      // =====================================================================
      // RESET TEST (SESSION 27: Added pause state reset)
      // =====================================================================

      function resetTest() {
        testState = {
          active: false,
          paused: false, // SESSION 27
          startTime: null,
          endTime: null,
          pauseStartTime: null, // SESSION 27
          totalPausedTime: 0, // SESSION 27
          currentLineIndex: 0,
          currentCharIndex: 0,
          totalCharsTyped: 0,
          totalErrors: 0,
          completedLines: new Set(),
          errorOnCurrentChar: false,
        };

        if (currentData) {
          while (
            testState.currentLineIndex < currentData.total_lines &&
            (!currentData.lines[testState.currentLineIndex] ||
              currentData.lines[testState.currentLineIndex].typing_sequence
                .length === 0)
          ) {
            testState.currentLineIndex++;
          }
        }

        document.body.classList.remove("test-active");
        hidePauseOverlay(); // SESSION 27

        renderCode();
        updateStats();
        updatePauseButton(); // SESSION 27
        updateStatus("Press any key to start...");

        requestAnimationFrame(() => {
          const firstLine = document.getElementById(
            `line-${testState.currentLineIndex}`
          );
          if (firstLine) {
            const targetY =
              firstLine.offsetTop -
              window.innerHeight / 4 +
              firstLine.offsetHeight / 4;
            window.scrollTo({
              top: targetY,
              behavior: "auto",
            });
          }
        });
      }

      // =====================================================================
      // SESSION 27: PAUSE/RESUME TOGGLE
      // =====================================================================

      function togglePause() {
        if (!testState.active) {
          console.log("Cannot pause: test not active");
          return;
        }

        if (testState.paused) {
          // RESUME
          console.log("Resuming test");

          const pauseDuration = Date.now() - testState.pauseStartTime;
          testState.totalPausedTime += pauseDuration;

          testState.paused = false;
          testState.pauseStartTime = null;

          hidePauseOverlay();
          updatePauseButton();
          updateStatus("Typing...", "success");

          document.getElementById("codeDisplay").focus();
        } else {
          // PAUSE
          console.log("Pausing test");

          testState.paused = true;
          testState.pauseStartTime = Date.now();

          showPauseOverlay();
          updatePauseButton();
          updateStatus("Paused (Tab to resume)", "warning");
        }

        updateStats();
      }

      // =====================================================================
      // SESSION 27: PAUSE OVERLAY UI
      // =====================================================================

      function showPauseOverlay() {
        hidePauseOverlay();

        const overlay = document.createElement("div");
        overlay.id = "pauseOverlay";
        overlay.className = "pause-overlay";
        overlay.innerHTML = `
      <div class="pause-content">
        <div class="pause-icon">‚∏∏</div>
        <h2 class="text-3xl font-bold mb-4">Paused</h2>
        <p class="text-lg mb-2">Press <kbd class="pause-kbd">Tab</kbd> to resume</p>
        <p class="text-sm text-gray-400 mt-4">or <kbd class="pause-kbd">Esc</kbd> to reset test</p>
      </div>
    `;
        document.body.appendChild(overlay);

        overlay.addEventListener("click", togglePause);
      }

      function hidePauseOverlay() {
        const overlay = document.getElementById("pauseOverlay");
        if (overlay) {
          overlay.remove();
        }
      }

      // =====================================================================
      // SESSION 27: UPDATE PAUSE BUTTON LABEL
      // =====================================================================

      function updatePauseButton() {
        const btn = document.getElementById("pauseBtn");
        if (!btn) return;

        if (testState.paused) {
          btn.textContent = "‚ñ∂Ô∏è Resume";
          btn.classList.add("paused-state");
        } else {
          btn.textContent = "‚∏∏ Pause";
          btn.classList.remove("paused-state");
        }

        if (!testState.active) {
          btn.disabled = true;
          btn.classList.add("opacity-50", "cursor-not-allowed");
        } else {
          btn.disabled = false;
          btn.classList.remove("opacity-50", "cursor-not-allowed");
        }
      }

      // =====================================================================
      // RENDER CODE
      // =====================================================================

      function renderCode() {
        if (!currentData) return;

        const display = document.getElementById("codeLines");
        display.innerHTML = "";

        currentData.lines.forEach((lineData, lineIndex) => {
          const lineDiv = document.createElement("div");
          lineDiv.className = "line flex";
          lineDiv.id = `line-${lineIndex}`;
          if (lineIndex === testState.currentLineIndex) {
            lineDiv.classList.add("test-active-line");
          }
          const lineNum = document.createElement("span");
          lineNum.className = "line-number";
          lineNum.textContent = lineData.line_number + 1;
          lineDiv.appendChild(lineNum);
          const contentDiv = document.createElement("div");
          contentDiv.className = "flex-1";
          contentDiv.style.paddingLeft = `${lineData.indent_level * 16}px`;
          contentDiv.id = `line-content-${lineIndex}`;
          renderLineTokens(contentDiv, lineData, lineIndex);
          lineDiv.appendChild(contentDiv);
          display.appendChild(lineDiv);
        });
      }

      // =====================================================================
      // RENDER LINE TOKENS (PHASE 3.5: PROGRESSIVE REVEAL)
      // =====================================================================

      function renderLineTokens(container, lineData, lineIndex) {
        let currentCol = 0;
        let typedCharCount = 0;

        const isCurrentLine = lineIndex === testState.currentLineIndex;
        const isCompletedLine = testState.completedLines.has(lineIndex);
        const isFutureLine = lineIndex > testState.currentLineIndex;

        lineData.display_tokens.forEach((token, tokenIndex) => {
          if (token.start_col > currentCol) {
            const spaces = " ".repeat(token.start_col - currentCol);
            container.appendChild(document.createTextNode(spaces));
          }
          const baseCssClass = getCssClass(token.type, token.text);
          if (token.typeable) {
            for (let i = 0; i < token.text.length; i++) {
              const charSpan = document.createElement("span");
              charSpan.textContent = token.text[i];
              charSpan.className = baseCssClass;
              if (isCompletedLine) {
              } else if (isFutureLine) {
                charSpan.classList.add("char-untyped");
              } else if (isCurrentLine) {
                if (typedCharCount < testState.currentCharIndex) {
                } else if (typedCharCount === testState.currentCharIndex) {
                  if (testState.errorOnCurrentChar) {
                    charSpan.classList.add("char-error");
                  } else {
                    charSpan.classList.add("char-current");
                  }
                  charSpan.classList.add("char-untyped");
                  charSpan.id = "current-char";
                } else {
                  charSpan.classList.add("char-untyped");
                }
              }
              container.appendChild(charSpan);
              typedCharCount++;
            }
          } else {
            const tokenSpan = document.createElement("span");
            tokenSpan.textContent = token.text;
            tokenSpan.className = baseCssClass;

            if (isCompletedLine) {
            } else if (isFutureLine) {
              tokenSpan.classList.add("char-untyped");
            } else if (isCurrentLine) {
              const currentCharInfo =
                lineData.char_map[String(testState.currentCharIndex)];
              const currentDisplayCol = currentCharInfo?.display_col || 0;

              const tokenStartsAfterCursor =
                token.start_col > currentDisplayCol;

              if (tokenStartsAfterCursor) {
                tokenSpan.classList.add("char-untyped");
              }
            }
            container.appendChild(tokenSpan);
          }
          currentCol = token.end_col;
        });
      }

      // =====================================================================
      // UPDATE STATS DISPLAY (SESSION 27: Modified for pause)
      // =====================================================================

      function updateStats() {
        if (!currentData) return;
        const currentLine = currentData.lines[testState.currentLineIndex];
        const progress = currentLine
          ? `${testState.currentCharIndex}/${currentLine.typing_sequence.length}`
          : "0/0";
        let wpm = 0;
        let accuracy = 100;

        // SESSION 27: Only calculate WPM when active and not paused
        if (testState.active && testState.startTime && !testState.paused) {
          const elapsedSeconds = getElapsedTime(testState);
          wpm = calculateWPM(testState.totalCharsTyped, elapsedSeconds);
        }

        if (testState.totalCharsTyped > 0) {
          accuracy = calculateAccuracy(
            testState.totalCharsTyped,
            testState.totalErrors
          );
        }

        const preset = document.querySelector(
          'input[name="typingMode"]:checked'
        ).value;
        const presetName = PRESETS[preset].name;

        document.getElementById("stats").innerHTML = `
            <div class="grid grid-cols-6 gap-4 text-sm">
                <div><div class="text-gray-400">Language</div><div class="font-bold">${
                  currentData.language
                }</div></div>
                <div><div class="text-gray-400">Mode</div><div class="font-bold">${presetName}</div></div>
                <div><div class="text-gray-400">Line Progress</div><div class="font-bold">${
                  testState.currentLineIndex + 1
                }/${currentData.total_lines}</div></div>
                <div><div class="text-gray-400">Char Progress</div><div class="font-bold">${progress}</div></div>
                <div><div class="text-gray-400">WPM</div><div class="font-bold">${wpm}</div></div>
                <div><div class="text-gray-400">Accuracy</div><div class="font-bold ${
                  accuracy < 95 ? "text-yellow-400" : "text-green-400"
                }">${accuracy}%</div></div>
            </div>`;
      }

      // =====================================================================
      // UPDATE STATUS MESSAGE
      // =====================================================================

      function updateStatus(message, type = "info") {
        const statusEl = document.getElementById("testStatus");
        const colors = {
          info: "text-gray-400",
          success: "text-green-400",
          error: "text-red-400",
          warning: "text-yellow-400",
        };
        statusEl.innerHTML = `<span class="${colors[type]}">${message}</span>`;
      }

      // =====================================================================
      // KEYBOARD INPUT HANDLER (SESSION 27: Added pause handling)
      // =====================================================================

      function handleKeyPress(event) {
        // =====================================================================
        // SESSION 27: TAB KEY FOR PAUSE/RESUME (HANDLE FIRST)
        // =====================================================================

        if (event.key === "Tab" && testState.active) {
          event.preventDefault();
          togglePause();
          return;
        }

        // =====================================================================
        // BLOCK INPUT DURING PAUSE (EXCEPT ESC)
        // =====================================================================

        if (testState.paused) {
          if (event.key === "Escape") {
            event.preventDefault();
            closeModal();
            resetTest();
          }
          return; // Block all other input while paused
        }

        // =====================================================================
        // EXISTING SHORTCUTS
        // =====================================================================

        if (event.ctrlKey || event.metaKey || event.altKey) return;
        if (event.key === "Escape") {
          event.preventDefault();
          closeModal();
          resetTest();
          return;
        }
        if (event.key.length > 1 && event.key !== "Enter" && event.key !== " ")
          return;
        event.preventDefault();
        if (!currentData) return;

        if (!testState.active) {
          testState.active = true;
          testState.startTime = Date.now();
          updateStatus("Typing...", "success");
          document.body.classList.add("test-active");
          updatePauseButton(); // SESSION 27: Enable pause button
        }

        const currentLine = currentData.lines[testState.currentLineIndex];
        if (!currentLine) return;
        const expectedChar =
          currentLine.typing_sequence[testState.currentCharIndex];
        const typedKey = event.key;

        if (typedKey === expectedChar) {
          testState.currentCharIndex++;
          testState.totalCharsTyped++;
          testState.errorOnCurrentChar = false;
          updateDisplay();
          if (
            testState.currentCharIndex >= currentLine.typing_sequence.length
          ) {
            setTimeout(() => {
              moveToNextLine();
            }, 50);
          }
        } else {
          testState.totalErrors++;
          testState.errorOnCurrentChar = true;
          updateDisplay();
          updateStats();
        }
      }

      // =====================================================================
      // MOVE TO NEXT LINE
      // =====================================================================

      function moveToNextLine() {
        testState.completedLines.add(testState.currentLineIndex);
        testState.currentLineIndex++;
        testState.currentCharIndex = 0;
        testState.errorOnCurrentChar = false;
        while (testState.currentLineIndex < currentData.total_lines) {
          const nextLine = currentData.lines[testState.currentLineIndex];
          if (
            nextLine &&
            nextLine.typing_sequence &&
            nextLine.typing_sequence.length > 0
          ) {
            break;
          }
          testState.completedLines.add(testState.currentLineIndex);
          testState.currentLineIndex++;
        }
        if (testState.currentLineIndex >= currentData.total_lines) {
          completeTest();
        } else {
          renderCode();
          updateStats();
          setTimeout(manualSmartScroll, 0);
        }
      }

      // =====================================================================
      // MANUAL SMART SCROLL LOGIC
      // =====================================================================
      function manualSmartScroll() {
        const nextLineEl = document.getElementById(
          `line-${testState.currentLineIndex}`
        );
        if (!nextLineEl) return;

        const currentScrollY = window.scrollY;
        const viewportHeight = window.innerHeight;

        const targetY =
          nextLineEl.offsetTop -
          viewportHeight / 4 +
          nextLineEl.offsetHeight / 4;

        if (targetY > currentScrollY) {
          window.scrollTo({
            top: targetY,
          });
        }
      }

      // =====================================================================
      // UPDATE DISPLAY
      // =====================================================================

      function updateDisplay() {
        const currentLine = currentData.lines[testState.currentLineIndex];
        const contentDiv = document.getElementById(
          `line-content-${testState.currentLineIndex}`
        );
        if (contentDiv && currentLine) {
          contentDiv.innerHTML = "";
          renderLineTokens(contentDiv, currentLine, testState.currentLineIndex);
        }
        document.querySelectorAll(".line").forEach((line, idx) => {
          if (idx === testState.currentLineIndex) {
            line.classList.add("test-active-line");
          } else {
            line.classList.remove("test-active-line");
          }
        });
        updateStats();
      }

      // =====================================================================
      // COMPLETE TEST (SESSION 27: Uses getElapsedTime())
      // =====================================================================

      function completeTest() {
        testState.active = false;
        testState.endTime = Date.now();
        document.body.classList.remove("test-active");

        // SESSION 27: Use getElapsedTime() for accurate timing
        const elapsed = getElapsedTime(testState);
        const timeStr = formatTime(elapsed);
        const wpm = calculateWPM(testState.totalCharsTyped, elapsed);
        const accuracy = calculateAccuracy(
          testState.totalCharsTyped,
          testState.totalErrors
        );

        // SESSION 26: Save stats to localStorage
        if (currentSnippetInfo.id) {
          saveSnippetStats(currentSnippetInfo.id, wpm, accuracy);
        }

        // SESSION 27: Disable pause button on completion
        updatePauseButton();

        showCompletionModal(wpm, accuracy, timeStr);
        updateStats();
      }

      // =====================================================================
      // SHOW COMPLETION MODAL (SESSION 26: Updated buttons)
      // =====================================================================

      function showCompletionModal(wpm, accuracy, timeStr) {
        const overlay = document.createElement("div");
        overlay.className = "modal-overlay";
        overlay.id = "completionModal";
        overlay.innerHTML = `
  <div class="modal-content">
    <div class="modal-title">üéâ Test Complete!</div>
    <div class="modal-subtitle">Great job on completing the test</div>
    <div class="modal-stats">
      <div class="modal-stat">
        <div class="modal-stat-label">Words Per Minute</div>
        <div class="modal-stat-value">${wpm}</div>
      </div>
      <div class="modal-stat">
        <div class="modal-stat-label">Accuracy</div>
        <div class="modal-stat-value">${accuracy}%</div>
      </div>
      <div class="modal-stat">
        <div class="modal-stat-label">Time</div>
        <div class="modal-stat-value">${timeStr}</div>
      </div>
    </div>

    <div class="modal-buttons">
      <button class="modal-button modal-button-primary" onclick="retryTest()">
        üîÑ Retry
      </button>
      <button
        class="modal-button modal-button-primary"
        onclick="loadRandomSnippet()"
      >
        üé≤ Random Snippet
      </button>
      <button
        class="modal-button modal-button-secondary"
        onclick="window.location.href='library.html'"
      >
        üìö Back to Library
      </button>
      <button
        class="modal-button modal-button-secondary"
        onclick="closeModal()"
      >
        ‚öôÔ∏è Change Settings
      </button>
    </div>
  </div>
      `;
        document.body.appendChild(overlay);
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) closeModal();
        });
      }

      // =====================================================================
      // MODAL ACTIONS
      // =====================================================================

      function closeModal() {
        const modal = document.getElementById("completionModal");
        if (modal) modal.remove();
      }

      function retryTest() {
        closeModal();
        resetTest();
      }

      // Make functions globally accessible for onclick handlers
      window.togglePause = togglePause;
      window.retryTest = retryTest;
      window.loadRandomSnippet = loadRandomSnippet;
      window.closeModal = closeModal;

      // =====================================================================
      // CSS CLASS HELPER
      // =====================================================================

      function getCssClass(type, text) {
        if (["(", ")", "[", "]", "{", "}", "<", ">"].includes(type))
          return "bracket";
        const keywords = [
          "def",
          "function",
          "class",
          "return",
          "if",
          "elif",
          "else",
          "for",
          "while",
          "import",
          "from",
          "as",
          "const",
          "let",
          "var",
          "async",
          "await",
          "interface",
          "type",
          "export",
          "default",
        ];
        if (keywords.includes(type)) return type;
        if (type.includes("comment")) return "comment";
        if (type.includes("string")) return type.replace(/_/g, "_");
        if (type === "integer" || type === "number" || type === "float")
          return "number";
        if (type.includes("identifier")) return type;
        if (
          ["->", "=>", "=", "+", "-", "*", "/", "%", "++", "--"].includes(type)
        )
          return "operator";
        if ([":", ";", ",", "."].includes(type)) return "punctuation";
        return type.replace(/[^a-zA-Z0-9_]/g, "_");
      }

      // =====================================================================
      // EVENT LISTENERS (UPDATED FOR PHASE 5.2)
      // =====================================================================

      // Global keydown listener (can be attached immediately)
      document.addEventListener("keydown", handleKeyPress);

      // Wait for DOM to be ready before attaching element-specific listeners
      document.addEventListener("DOMContentLoaded", () => {
        // Load saved config
        const config = loadConfig();

        // Set up language selector
        const languageSelect = document.getElementById("languageSelect");
        languageSelect.value = config.language;
        languageSelect.addEventListener("change", (e) => {
          loadLanguage(e.target.value);
          saveConfig({
            preset: document.querySelector('input[name="typingMode"]:checked')
              .value,
            language: e.target.value,
          });
        });

        // Set up typing mode radios
        const presetRadio = document.querySelector(
          `input[name="typingMode"][value="${config.preset}"]`
        );
        if (presetRadio) {
          presetRadio.checked = true;
        }

        document
          .querySelectorAll('input[name="typingMode"]')
          .forEach((radio) => {
            radio.addEventListener("change", () => {
              if (rawData) {
                const preset = document.querySelector(
                  'input[name="typingMode"]:checked'
                ).value;

                currentData = {
                  ...rawData,
                  lines: rawData.lines.map((line) =>
                    applyExclusionConfig(line, preset)
                  ),
                };

                resetTest();
                saveConfig({
                  preset: preset,
                  language: document.getElementById("languageSelect").value,
                });
              }
            });
          });

        // Set up reset button
        document.getElementById("resetBtn").addEventListener("click", () => {
          resetTest();
        });

        // Set up code display focus handlers
        const codeDisplay = document.getElementById("codeDisplay");
        codeDisplay.addEventListener("click", () => {
          codeDisplay.classList.add("focused");
        });
        codeDisplay.addEventListener("blur", () => {
          codeDisplay.classList.remove("focused");
        });

        // Load initial language and focus
        loadLanguage(config.language);
        codeDisplay.focus();
      });
    </script>
  </body>
</html>
